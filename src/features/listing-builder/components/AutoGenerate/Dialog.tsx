import { useChat } from '@ai-sdk/react';
import { useMutation } from '@tanstack/react-query';
import { DefaultChatTransport } from 'ai';
import { useAtom, useSetAtom } from 'jotai';
import { marked } from 'marked';
import { AnimatePresence } from 'motion/react';
import { useRouter } from 'next/router';
import posthog from 'posthog-js';
import { useCallback, useEffect, useMemo, useState } from 'react';

import {
  type RewardInputSchema,
  type TRewardsGenerateResponse,
} from '@/app/api/sponsor-dashboard/ai-generate/rewards/route';
import { type TTitleGenerateResponse } from '@/app/api/sponsor-dashboard/ai-generate/title/route';
import { type TTokenGenerateResponse } from '@/app/api/sponsor-dashboard/ai-generate/token/route';
import { AnimateChangeInHeight } from '@/components/shared/AnimateChangeInHeight';
import { Dialog, DialogContent } from '@/components/ui/dialog';
import { ScrollArea } from '@/components/ui/scroll-area';
import { tokenList } from '@/constants/tokenList';
import { type BountyType } from '@/generated/prisma/enums';
import { type Skills } from '@/interface/skills';
import { api } from '@/lib/api';
import { useUser } from '@/store/user';
import { cn } from '@/utils/cn';

import { fetchTokenUSDValue } from '@/features/wallet/utils/fetchTokenUSDValue';

import {
  generatedListingAtom,
  type GeneratedListingData,
  isAutoGenerateOpenAtom,
} from '../../atoms';
import { type TEligibilityQuestion } from '../../types/schema';
import { AutoGenerateChat } from './Chat';
import { prepareCompanyInfo } from './company-info';
import { AutoGenerateForm } from './Form';
import { AutoGenerateStageType } from './Type';

function adjustPrompt(prompt: string, refine: boolean) {
  if (refine) {
    return `
    This is a refine request, so iterate the previous output based on current input.
    Directly provide the output description, do not include any other text like greeting, reasoning, etc.
    User Message: ${prompt}
    `;
  }
  return `
  Directly provide the output description, do not include any other text like greeting, reasoning, etc
  User Message: ${prompt}
  `;
}

export function AutoGenerateDialog() {
  const [stage, setStage] = useState<'type' | 'form' | 'chat'>('type');
  const [type, setType] = useState<BountyType>('bounty');
  const [open, setOpen] = useAtom(isAutoGenerateOpenAtom);
  const [input, setInput] = useState('');
  const setGeneratedListing = useSetAtom(generatedListingAtom);
  const { user } = useUser();
  const router = useRouter();
  const [tokenUsdValue, setTokenUsdValue] = useState<number>(1);

  const [scrollEl, setScrollEl] = useState<HTMLDivElement | null>(null);

  const scrollCallbackRef = useCallback((node: HTMLDivElement | null) => {
    if (node !== null) {
      setScrollEl(node);
    }
  }, []);

  const { messages, sendMessage, status, setMessages } = useChat({
    transport: new DefaultChatTransport({
      api: '/api/sponsor-dashboard/ai-generate/description',
    }),
  });

  const {
    data: token,
    mutateAsync: callToken,
    reset: _resetToken,
  } = useMutation({
    mutationFn: async ({ description }: { description: string }) =>
      (
        await api.post<TTokenGenerateResponse>(
          '/api/sponsor-dashboard/ai-generate/token',
          {
            description,
          },
        )
      ).data,
  });

  const {
    data: title,
    mutateAsync: callTitle,
    reset: _resetTitle,
    isIdle: _isTitleIdle,
    isError: _isTitleError,
    isPending: _isTitlePending,
    isSuccess: _isTitleSuccess,
  } = useMutation({
    mutationFn: async ({
      description,
      type,
    }: {
      description: string;
      type: BountyType;
    }) =>
      (
        await api.post<TTitleGenerateResponse>(
          '/api/sponsor-dashboard/ai-generate/title',
          { description, type },
        )
      ).data,
  });

  const {
    data: eligibilityQuestions,
    mutateAsync: callEligibilityQuestions,
    reset: _resetEligibilityQuestions,
    isIdle: _isEligibilityQuestionsIdle,
    isError: _isEligibilityQuestionsError,
    isPending: _isEligibilityQuestionsPending,
    isSuccess: _isEligibilityQuestionsSuccess,
  } = useMutation({
    mutationFn: async ({
      description,
      type,
    }: {
      description: string;
      type: BountyType;
    }) =>
      (
        await api.post<TEligibilityQuestion[]>(
          '/api/sponsor-dashboard/ai-generate/questions',
          {
            description,
            type,
          },
        )
      ).data,
  });

  const {
    data: rewards,
    mutateAsync: callRewards,
    reset: _resetRewards,
    isIdle: _isRewardsIdle,
    isError: _isRewardsError,
    isPending: _isRewardsPending,
    isSuccess: _isRewardsSuccess,
  } = useMutation({
    mutationFn: async (input: RewardInputSchema) =>
      (
        await api.post<TRewardsGenerateResponse>(
          '/api/sponsor-dashboard/ai-generate/rewards',
          input,
        )
      ).data,
  });

  const {
    data: skills,
    mutateAsync: callSkills,
    reset: _resetSkills,
    isIdle: _isSkillsIdle,
    isError: _isSkillsError,
    isPending: _isSkillsPending,
    isSuccess: _isSkillsSuccess,
  } = useMutation({
    mutationFn: async ({ description }: { description: string }) =>
      (
        await api.post<Skills>('/api/sponsor-dashboard/ai-generate/skills', {
          description,
        })
      ).data,
  });

  const handleTypeSelect = (type: BountyType) => {
    setType(type);
    setStage('form');
  };

  const handleSendMessage = async (refine: boolean = false) => {
    const text = input;
    setInput('');
    setStage('chat');
    const token = (await callToken({ description: text }))?.token || 'USDC';
    const tokenItem = tokenList.find((s) => s.tokenSymbol === token);
    const tokenUsdAmount = tokenItem
      ? await fetchTokenUSDValue(tokenItem.mintAddress)
      : 1;
    setTokenUsdValue(tokenUsdAmount);
    sendMessage(
      {
        role: 'user',
        parts: [{ type: 'text', text: adjustPrompt(text, refine) }],
      },
      {
        body: {
          token,
          tokenUsdAmount,
          company: user?.currentSponsor
            ? prepareCompanyInfo(user?.currentSponsor)
            : 'unknown sponsor',
          listingType: type,
        },
      },
    );
  };

  useEffect(() => {
    console.log(status);
    console.log(messages);
  }, [messages, status]);

  const description = useMemo(() => {
    return (
      messages
        ?.filter((message) => message.role === 'assistant')
        ?.pop()
        ?.parts.filter((part) => part.type === 'text')
        ?.map((part) => part.text)
        .join('') || ''
    );
  }, [messages]);

  useEffect(() => {
    if (status === 'ready' && !!description) {
      Promise.all([
        callTitle({ description, type }),
        callEligibilityQuestions({ description, type }),
        callRewards({
          description,
          type,
          token: token?.token || 'USDC',
          tokenUsdValue,
        }),
        callSkills({ description }),
      ]);
    }
  }, [description, status]);

  const handleProceed = async () => {
    const html = await marked.parse(description || '', { gfm: true });

    const processedHtml = html.replace(
      /<a\s+(?:[^>]*?\s+)?href=(["'])(.*?)\1/g,
      '<a href=$1$2$1 target="_blank" rel="noopener noreferrer"',
    );
    const generatedData: GeneratedListingData = {
      description: processedHtml,
      token: token?.token,
      title: title?.title,
      rewards,
      skills,
      eligibilityQuestions,
      type,
    };

    setGeneratedListing(generatedData);
    await router.push(`/dashboard/new?type=${type}&autogenerated=true`);
    setOpen(false);
  };

  return (
    <Dialog
      open={open}
      onOpenChange={(open) => {
        if (!open) posthog.capture('close_auto-generate');
        setOpen(open);
      }}
    >
      <DialogContent
        className={cn(
          'gap-0 overflow-hidden border-0 p-0 focus-visible:ring-0 sm:max-w-160',
        )}
        style={{
          borderImageWidth: '0px !important',
        }}
        onPointerDownOutside={(e) => e.preventDefault()}
        onInteractOutside={(e) => e.preventDefault()}
        aria-describedby="Auto Generate Listing"
        hideCloseIcon
        autoFocus={false}
      >
        <button className="sr-only" />
        <ScrollArea
          type="scroll"
          className="relative max-h-160 py-0"
          viewportProps={{
            ref: scrollCallbackRef,
            className: 'h-full *:h-full',
          }}
        >
          <AnimateChangeInHeight>
            <div className={cn('h-full p-0')}>
              <AnimatePresence mode="popLayout">
                {stage === 'type' && (
                  <AutoGenerateStageType
                    type={type}
                    setType={handleTypeSelect}
                  />
                )}
                {stage === 'form' && (
                  <AutoGenerateForm
                    type={type}
                    setType={setType}
                    input={input}
                    setInput={setInput}
                    onSubmit={() => handleSendMessage(false)}
                  />
                )}
                {stage === 'chat' && (
                  <AutoGenerateChat
                    handleProceed={handleProceed}
                    description={description}
                    error={status === 'error'}
                    loading={status === 'streaming'}
                    input={input}
                    setInput={setInput}
                    handleRefine={() => handleSendMessage(true)}
                    handleBack={() => {
                      setStage('form');
                      setMessages([]);
                    }}
                    scrollEl={scrollEl}
                  />
                )}
              </AnimatePresence>
            </div>
          </AnimateChangeInHeight>
        </ScrollArea>
      </DialogContent>
    </Dialog>
  );
}
