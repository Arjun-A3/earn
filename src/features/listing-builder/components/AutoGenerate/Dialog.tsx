import { useChat } from '@ai-sdk/react';
import { useMutation } from '@tanstack/react-query';
import { DefaultChatTransport } from 'ai';
import { useAtom, useSetAtom } from 'jotai';
import { marked } from 'marked';
import { AnimatePresence } from 'motion/react';
import { useRouter } from 'next/router';
import posthog from 'posthog-js';
import { useCallback, useEffect, useMemo, useRef, useState } from 'react';

import {
  type RewardInputSchema,
  type TRewardsGenerateResponse,
} from '@/app/api/sponsor-dashboard/ai-generate/rewards/route';
import { type TTitleGenerateResponse } from '@/app/api/sponsor-dashboard/ai-generate/title/route';
import { type TTokenGenerateResponse } from '@/app/api/sponsor-dashboard/ai-generate/token/route';
import { AnimateChangeInHeight } from '@/components/shared/AnimateChangeInHeight';
import { Dialog, DialogContent } from '@/components/ui/dialog';
import { ScrollArea } from '@/components/ui/scroll-area';
import { tokenList } from '@/constants/tokenList';
import { type BountyType } from '@/generated/prisma/enums';
import { type Skills } from '@/interface/skills';
import { api } from '@/lib/api';
import { useUser } from '@/store/user';
import { cn } from '@/utils/cn';

import { fetchTokenUSDValue } from '@/features/wallet/utils/fetchTokenUSDValue';

import {
  generatedListingAtom,
  type GeneratedListingData,
  isAutoGenerateOpenAtom,
} from '../../atoms';
import { type TEligibilityQuestion } from '../../types/schema';
import { AutoGenerateChat } from './Chat';
import { prepareCompanyInfo } from './company-info';
import { AutoGenerateForm } from './Form';
import { AutoGenerateStageType } from './Type';

function adjustPrompt(prompt: string, refine: boolean) {
  if (refine) {
    return `
    This is a refine request, so iterate the previous output based on current input.
    Directly provide the output description, do not include any other text like greeting, reasoning, etc.
    User Message: ${prompt}
    `;
  }
  return `
  Directly provide the output description, do not include any other text like greeting, reasoning, etc
  User Message: ${prompt}
  `;
}

export function AutoGenerateDialog() {
  const [stage, setStage] = useState<'type' | 'form' | 'chat'>('type');
  const [type, setType] = useState<BountyType>('bounty');
  const [open, setOpen] = useAtom(isAutoGenerateOpenAtom);
  const [input, setInput] = useState('');
  const setGeneratedListing = useSetAtom(generatedListingAtom);
  const { user } = useUser();
  const router = useRouter();
  const [tokenUsdValue, setTokenUsdValue] = useState<number>(1);
  const [proceedLoading, setProceedLoading] = useState(false);
  const [proceedDisabled, setProceedDisabled] = useState(true);
  const [isThinking, setIsThinking] = useState(false);
  const generatedDataRef = useRef<{
    isReady: boolean;
    title?: typeof title;
    rewards?: typeof rewards;
    skills?: typeof skills;
    eligibilityQuestions?: typeof eligibilityQuestions;
  }>({ isReady: false });
  const hasExecutedRef = useRef(true);

  const [scrollEl, setScrollEl] = useState<HTMLDivElement | null>(null);

  const scrollCallbackRef = useCallback((node: HTMLDivElement | null) => {
    if (node !== null) {
      setScrollEl(node);
    }
  }, []);

  const { messages, sendMessage, status, setMessages } = useChat({
    transport: new DefaultChatTransport({
      api: '/api/sponsor-dashboard/ai-generate/description',
    }),
  });

  const { data: token, mutateAsync: callToken } = useMutation({
    mutationFn: async ({ description }: { description: string }) =>
      (
        await api.post<TTokenGenerateResponse>(
          '/api/sponsor-dashboard/ai-generate/token',
          {
            description,
          },
        )
      ).data,
  });

  const { data: title, mutateAsync: callTitle } = useMutation({
    mutationFn: async ({
      description,
      type,
    }: {
      description: string;
      type: BountyType;
    }) =>
      (
        await api.post<TTitleGenerateResponse>(
          '/api/sponsor-dashboard/ai-generate/title',
          { description, type },
        )
      ).data,
  });

  const { data: eligibilityQuestions, mutateAsync: callEligibilityQuestions } =
    useMutation({
      mutationFn: async ({
        description,
        type,
      }: {
        description: string;
        type: BountyType;
      }) =>
        (
          await api.post<TEligibilityQuestion[]>(
            '/api/sponsor-dashboard/ai-generate/questions',
            {
              description,
              type,
            },
          )
        ).data,
    });

  const { data: rewards, mutateAsync: callRewards } = useMutation({
    mutationFn: async (input: RewardInputSchema) =>
      (
        await api.post<TRewardsGenerateResponse>(
          '/api/sponsor-dashboard/ai-generate/rewards',
          input,
        )
      ).data,
  });

  const { data: skills, mutateAsync: callSkills } = useMutation({
    mutationFn: async ({ description }: { description: string }) =>
      (
        await api.post<Skills>('/api/sponsor-dashboard/ai-generate/skills', {
          description,
        })
      ).data,
  });

  const handleTypeSelect = (type: BountyType) => {
    setType(type);
    setStage('form');
  };

  const handleSendMessage = async (refine: boolean = false) => {
    const text = input;
    setInput('');
    setStage('chat');
    generatedDataRef.current = { isReady: false };
    setProceedDisabled(true);
    setIsThinking(true);
    const token = (await callToken({ description: text }))?.token || 'USDC';
    const tokenItem = tokenList.find((s) => s.tokenSymbol === token);
    const tokenUsdAmount = tokenItem
      ? await fetchTokenUSDValue(tokenItem.mintAddress)
      : 1;
    setTokenUsdValue(tokenUsdAmount);
    await sendMessage(
      {
        role: 'user',
        parts: [{ type: 'text', text: adjustPrompt(text, refine) }],
      },
      {
        body: {
          token,
          tokenUsdAmount,
          company: user?.currentSponsor
            ? prepareCompanyInfo(user?.currentSponsor)
            : 'unknown sponsor',
          listingType: type,
        },
      },
    );
    setProceedDisabled(false);
  };

  useEffect(() => {
    console.log(status);
    console.log(messages);
    console.log('isDataReady', generatedDataRef.current.isReady);
  }, [messages, status]);

  const description = useMemo(() => {
    return (
      [...messages]
        ?.filter((message) => message.role === 'assistant')
        ?.pop()
        ?.parts.filter((part) => part.type === 'text')
        ?.map((part) => part.text)
        .join('') || ''
    );
  }, [messages]);

  useEffect(() => {
    const lastMessage = [...messages]?.pop();
    if (
      lastMessage?.role === 'assistant' &&
      lastMessage?.parts.filter((part) => part.type === 'text').length > 0 &&
      description?.length > 0
    ) {
      setIsThinking(false);
    }
  }, [messages, description]);

  useEffect(() => {
    if (status === 'streaming') {
      hasExecutedRef.current = false;
    }
  }, [status]);

  useEffect(() => {
    if (
      !hasExecutedRef.current &&
      status === 'ready' &&
      description?.length > 0
    ) {
      hasExecutedRef.current = true;
      generatedDataRef.current = { isReady: false };
      Promise.all([
        callTitle({ description, type }),
        callEligibilityQuestions({ description, type }),
        callRewards({
          description,
          type,
          token: token?.token || 'USDC',
          tokenUsdValue,
        }),
        callSkills({ description }),
      ]).then(
        ([titleResult, eligibilityResult, rewardsResult, skillsResult]) => {
          generatedDataRef.current = {
            isReady: true,
            title: titleResult,
            rewards: rewardsResult,
            skills: skillsResult,
            eligibilityQuestions: eligibilityResult,
          };
        },
      );
    } else {
      generatedDataRef.current = { isReady: false };
    }
  }, [description, status, type, token?.token, tokenUsdValue]);

  const handleProceed = async () => {
    setProceedLoading(true);

    console.log('isDataReady in proceed', generatedDataRef.current.isReady);
    while (!generatedDataRef.current.isReady) {
      console.log(
        'waiting for data, isReady:',
        generatedDataRef.current.isReady,
      );
      await new Promise((resolve) => setTimeout(resolve, 250));
    }

    const html = await marked.parse(description || '', { gfm: true });

    const processedHtml = html.replace(
      /<a\s+(?:[^>]*?\s+)?href=(["'])(.*?)\1/g,
      '<a href=$1$2$1 target="_blank" rel="noopener noreferrer"',
    );

    const { title, rewards, skills, eligibilityQuestions } =
      generatedDataRef.current;

    const generatedData: GeneratedListingData = {
      description: processedHtml,
      token: token?.token,
      title: title?.title,
      rewards,
      skills,
      eligibilityQuestions,
      type,
    };

    setGeneratedListing(generatedData);
    await router.push(`/dashboard/new?type=${type}&autogenerated=true`);
    setOpen(false);
    setProceedLoading(false);
  };

  return (
    <Dialog
      open={open}
      onOpenChange={(open) => {
        if (!open) posthog.capture('close_auto-generate');
        setOpen(open);
      }}
    >
      <DialogContent
        className={cn(
          'gap-0 overflow-hidden border-0 p-0 focus-visible:ring-0 sm:max-w-160',
        )}
        style={{
          borderImageWidth: '0px !important',
        }}
        onPointerDownOutside={(e) => e.preventDefault()}
        onInteractOutside={(e) => e.preventDefault()}
        aria-describedby="Auto Generate Listing"
        hideCloseIcon
        autoFocus={false}
      >
        <button className="sr-only" />
        <ScrollArea
          type="scroll"
          className="relative max-h-160 py-0"
          viewportProps={{
            ref: scrollCallbackRef,
            className: 'h-full *:h-full',
          }}
        >
          <AnimateChangeInHeight>
            <div className={cn('h-full p-0')}>
              <AnimatePresence mode="popLayout">
                {stage === 'type' && (
                  <AutoGenerateStageType
                    type={type}
                    setType={handleTypeSelect}
                  />
                )}
                {stage === 'form' && (
                  <AutoGenerateForm
                    type={type}
                    setType={setType}
                    input={input}
                    setInput={setInput}
                    onSubmit={() => handleSendMessage(false)}
                  />
                )}
                {stage === 'chat' && (
                  <AutoGenerateChat
                    handleProceed={handleProceed}
                    description={description}
                    isThinking={isThinking}
                    error={status === 'error'}
                    loading={status === 'streaming'}
                    input={input}
                    setInput={setInput}
                    handleRefine={() => handleSendMessage(true)}
                    handleBack={() => {
                      setStage('form');
                      setMessages([]);
                    }}
                    scrollEl={scrollEl}
                    isDisabled={proceedDisabled}
                    isLoading={proceedLoading}
                    isRefineDisabled={input.length === 0}
                  />
                )}
              </AnimatePresence>
            </div>
          </AnimateChangeInHeight>
        </ScrollArea>
      </DialogContent>
    </Dialog>
  );
}
